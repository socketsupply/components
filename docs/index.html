
    <!DOCTYPE html>

      <head>
  <title>Tonic - Component Based Architecture</title>
  <link href="https://fonts.googleapis.com/css?family=Caudex|Poppins:400,600|IBM+Plex+Mono:400,600" rel="stylesheet">
  <link href="index.css" rel="stylesheet">

  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="120x120">
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="128x128">
  <link rel="apple-touch-icon" type="image/png" href="favicon-152x152.png" sizes="152x152">
  <link rel="apple-touch-icon" type="image/png" href="favicon-167x167.png" sizes="167x167">
  <link rel="apple-touch-icon" type="image/png" href="favicon-180x180.png" sizes="180x180">

  <meta http-equiv="Content-Type" charset="utf-8" content="text/html">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1 user-scalable=no">
  <meta name="description" content="Component Based Architecture">

  <meta property="og:site_name", content="ConductorLab">
  <meta property="og:title", content="Tonic Components">
  <meta property="og:description" content="Component Based Architecture">
  <meta property="og:type", content="website">
  <meta property="og:url", content="https://hxoht.github.io/components">
  <meta property="og:image", content="https://hxoht.github.io/components/tonic_preview.png">
  <meta name="twitter:card", content="summary">
  <meta name="twitter:site", content="@conductorlab">
  <meta name="twitter:image", content="https://hxoht.github.io/components/tonic_preview.png">

  <!-- TODO: An issue with chartjs requires 'unsafe-inline' for now. -->

  <meta
    http-equiv="Content-Security-Policy"
    content="
      default-src 'self';
      font-src 'self' https:;
      img-src 'self' http: https: data:;
      style-src 'self' 'unsafe-inline' https:;
      script-src 'self' 'nonce-U29tZSBzdXBlciBzZWNyZXQ=';
      connect-src 'self' https:;
    "
  >
</head>


      <body data-page="docs">
        <div class="theme-picker">
          <icon-container src="./sprite.svg#theme" size="20px">
          </icon-container>
        </div>
        <nav>
          <a href="./index.html" class="logo">
            <svg>
              <use xlink:href="./logo-sprite.svg#tonic_logo">
            </svg>
          </a>

          <div class="page-selection">
            <a name="docs" href="./index.html">Docs</a>
            <a name="components" href="./examples.html">Examples</a>
          </div>

          <ul>
            
    <li>
      <a href="#intro" class="selected">Intro</a>
    </li>
  

    <li>
      <a href="#1.-getting-started" class="">1. Getting Started</a>
    </li>
  

    <li>
      <a href="#2.-properties" class="">2. Properties</a>
    </li>
  

    <li>
      <a href="#3.-methods" class="">3. Methods</a>
    </li>
  

    <li>
      <a href="#4.-styling" class="">4. Styling</a>
    </li>
  

    <li>
      <a href="#5.-events" class="">5. Events</a>
    </li>
  

    <li>
      <a href="#6.-state" class="">6. State</a>
    </li>
  

    <li>
      <a href="#7.-composition" class="">7. Composition</a>
    </li>
  

    <li>
      <a href="#8.-performance" class="">8. Performance</a>
    </li>
  

    <li>
      <a href="#9.-csp" class="">9. CSP</a>
    </li>
  

    <li>
      <a href="#api" class="">API</a>
    </li>
  
          </ul>

        </nav>
        <main>

          <div class="mobile-nav">
            <a name="docs" href="./index.html">Docs</a>
            <a name="components" href="./examples.html">Examples</a>
          </div>

          
    <section id="intro">
      <h1 id="intro">Intro</h1>
<div class="hero">
  <div class="logo">
    <svg>
      <use xlink:href="./logo-sprite.svg#tonic_logo">
    </svg>
  </div>
  <div class="tonic-icon">
    <svg>
      <use xlink:href="./logo-sprite.svg#tonic_icon">
    </svg>
  </div>
  <p class="intro-copy"><span class="first-word">Tonic</span> is a very small JavaScript class for building components â€” without React.</p>
  <center>
    <a href="https://github.com/hxoht/tonic">Core Library</a>
    <img width="24" height="24" title="" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEQUM1QkUxRUI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEQUM1QkUxRkI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdGQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjgwQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hfPRaQAAB6lJREFUeNrsW2mM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"/>
    <a href="https://github.com/hxoht/components">Examples</a>
  </center>
</div>

<p><span class="status"></span></p>
<div class="row">
  <h3>Features</h3>
  <div class="col">
    <ul>
      <li>Tonic is tiny. Less than 200 lines of code.</li>
      <li>One-way data binding. Pipe data through connected components.</li>
      <li>Mix in your own Routers, Reducers, Validators, etc.</li>
    </ul>
  </div>
  <div class="col">
    <ul>
      <li>React-like component composition.</li>
      <li>Prefer Javascript <i>template literals</i> to weird template languages.</li>
      <li>Prefer <i>event delegation</i> over individual handlers.</li>
    </ul>
  </div>
</div>

    </section>
  

    <section id="1.-getting-started">
      <h1 id="1-getting-started">1. Getting Started</h1>
<p>Building a component with Tonic starts by creating a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Javascript Class</a>.
The class should have at least one method named <em>render</em> which usually returns
a string of HTML.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGreeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// The render function can return a template-literal of HTML, it can include</span>
  <span class="hljs-comment">// other components as well. It can also return a dom node, we'll talk about</span>
  <span class="hljs-comment">// that later.</span>
  <span class="hljs-comment">//</span>
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div&gt;Hello, World.&lt;/div&gt;`</span>
  }
}</code></pre>
<hr>
<p>The name of your class will determine the html tag name for your component. A
class named <code>Greeting</code> will become <code>&lt;greeting&gt;&lt;/greeting&gt;</code>. Camel cased class
names will create hyphenated tag names, ie <code>MyGreeting</code> will become
<code>&lt;my-greeting&gt;&lt;/my-greeting&gt;</code>.</p>
<hr>
<p>Next, you need to tell the browser about your new class and it will create a
custom HTML tag for it. Your top most component should generally be added after
the <a href="https://caniuse.com/#search=domcontentloaded">DOM is ready</a>. Now any time the component&#39;s tag appears in your html, an
instance of your class will be created.</p>
<pre><code class="language-js">Tonic.add(MyGreeting)</code></pre>
<hr>
<p>After adding your Javascript to your HTML, you can start to use your component.
And remember, all custom tags require a closing tag.</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">my-greeting</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-greeting</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<hr>
<p>When the component is rendered by the browser, the result of your render
function will be inserted into the component tag.</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">my-greeting</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello, World.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">my-greeting</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<hr>
<p>The potential for components is that the complexity of a solution can be
hidden for the programmer who uses it. They can then focus more on the value
it produces and the properties they want to pass it.</p>

    </section>
  

    <section id="2.-properties">
      <h1 id="2-properties">2. Properties</h1>
<p>Properties can be used by a component to help it decide how it should appear or
how it should behave. In this case, <code>message</code> is our property and <code>Hello, World</code>
is our porperty value.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
      &lt;my-greeting message='Hello, World'&gt;&lt;/my-greeting&gt;
    `</span>
  }
}</code></pre>
<hr>
<p>Properties added to a component appear on the <code>this.props</code> object.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGreeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
      &lt;h1&gt;<span class="hljs-subst">${<span class="hljs-keyword">this</span>.props.message}</span>&lt;/h1&gt;
    `</span>
  }
}</code></pre>
<hr>
<p>There is no templating language in Tonic. It&#39;s just HTML &mdash; a limitation
of HTML is that it only understands string values. So if we want to pass more
complex property values to a component, Tonic can help. Notice the string we
would normally return is prefixed with <code>this.html</code>. This just helps Tonic to
understand your html better.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> data = [
  { <span class="hljs-attr">greeting</span>: <span class="hljs-string">'hello, world'</span> }
]

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.html<span class="hljs-string">`
      &lt;my-component title=<span class="hljs-subst">${data}</span>&gt;&lt;/my-component&gt;
    `</span>
  }
}</code></pre>
<hr>
<p>Now <code>this.props</code> has a reference to the <code>data</code> object.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
      &lt;h1&gt;<span class="hljs-subst">${<span class="hljs-keyword">this</span>.props.data[<span class="hljs-number">0</span>].greeting}</span>&lt;/h1&gt;
    `</span>
  }
}</code></pre>
<blockquote>
<p><b>A note about property names</b>. A prop named <code>fooBar=&#39;30&#39;</code> will become lowercased
(as per the HTML spec). If you want the property name to be camel cased when
added to the props object, use <code>foo-bar=&#39;30&#39;</code> to get <code>this.props.fooBar</code>.</p>
</blockquote>
<h3>Updating properties</h3>
<p>If you want to manually update a component, you should think of your document&#39;s
hierarchy and where in it the update should take place. It&#39;s better to update a
component higher up in the hierarchy and let the data cascade downward to child
components.</p>
<hr>
<p>To manually update a component you can use the <code>.reRender()</code> method. This method
receives either an object or a function. For example...</p>
<pre><code class="language-js"><span class="hljs-comment">// Update a component's properties</span>
<span class="hljs-keyword">this</span>.reRender(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> ({
  ...props,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>
}))

<span class="hljs-comment">// Reset a component's properties</span>
<span class="hljs-keyword">this</span>.reRender({ <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> })

<span class="hljs-comment">// Re-render a component with its existing properties</span>
<span class="hljs-keyword">this</span>.reRender()</code></pre>
<hr>
<p>The <code>.reRender()</code> method can also be called directly on a component.</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'parent'</span>).reRender({ <span class="hljs-attr">data</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, ..<span class="hljs-number">.9999</span>] })</code></pre>

    </section>
  

    <section id="3.-methods">
      <h1 id="3-methods">3. Methods</h1>
<p>A method is a function of a component. It can help to organize the internal
logic of a component.</p>
<p>All component methods are private by default. No one else can access them. But
in some cases you want to provide public access to a method.</p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">constructor</a> is a special method that is called once each time an
instance of your component is created. Here you can add a method to the root
element of your component that calls a method from the component.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  <span class="hljs-keyword">constructor</span> (node) {
    <span class="hljs-keyword">super</span>(node)

    <span class="hljs-keyword">this</span>.root.myMethod = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-keyword">this</span>.myMethod(n)
  }

  myMethod (n) {
    <span class="hljs-keyword">this</span>.root.innerHTML = <span class="hljs-string">`The number is <span class="hljs-subst">${n}</span>`</span>
  }
}</code></pre>
<p>Once the component has been created, the <code>exampleMethod</code> method can be called
on it.</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'foo'</span>).myMethod(<span class="hljs-number">42</span>)</code></pre>

    </section>
  

    <section id="4.-styling">
      <h1 id="4-styling">4. Styling</h1>
<p>Components should ship with as little CSS as possible and try to inherit
whenever possible from the document&#39;s stylesheets. Tonic supports two approaches
to styling components.</p>
<h3>Approach 1. Dynamic Stylesheets</h3>
<p>The value returned from the <code>stylesheet()</code> function will be attached to a style
element in the head of the document if and when the component is used (lazily).
Since the value is css, you can use any <code>css-in-js</code> library you want and it will
be easy to inspect and override from another stylesheet.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGreeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  stylesheet () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`

      my-greeting div {
        display: inline-block;
        border: 1px dotted #666;
        line-height: 90px;
      }

      my-greeting .tonic--my-greeting--show {
        display: flex;
      }
    `</span>
  }

  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div&gt;&lt;/div&gt;`</span>
  }
}</code></pre>
<p>Any classes you add should be prefixed so that they don&#39;t collide with any class
names which already exist in the document&#39;s stylesheet. We use this convention...</p>
<pre><code class="language-js">library--component-name--<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span></span></code></pre>
<h3>Approach 2. Inline styles</h3>
<p>Sometimes you want to use inline-styles. If your component has a <code>styles()</code>
method that returns an object and the <code>styles=&quot;...&quot;</code> attribute is found on an
html tag, Tonic will try to apply the matching style properties when the
<code>render()</code> method is called. Note that the styles are applied through Javascript
in a CSP-friendly way.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGreeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  styles () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">fontStyle</span>: {
        <span class="hljs-attr">color</span>: <span class="hljs-keyword">this</span>.props.fg,
        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'30px'</span>
      },
      <span class="hljs-attr">background</span>: {
        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-keyword">this</span>.props.bg,
        <span class="hljs-attr">padding</span>: <span class="hljs-string">'10px'</span>
      }
    }
  }

  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div styles="fontStyle background"&gt;<span class="hljs-subst">${<span class="hljs-keyword">this</span>.children}</span>&lt;/div&gt;`</span>
  }
}</code></pre>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-greeting</span> <span class="hljs-attr">fg</span>=<span class="hljs-string">"white"</span> <span class="hljs-attr">bg</span>=<span class="hljs-string">"red"</span>&gt;</span>Hello, World<span class="hljs-tag">&lt;/<span class="hljs-name">my-greeting</span>&gt;</span></code></pre>

    </section>
  

    <section id="5.-events">
      <h1 id="5-events">5. Events</h1>
<p>Tonic helps you capture events that happen when someone interacts with your
component. It also helps you organize that code.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// You can listen to any DOM event that happens in your component</span>
  <span class="hljs-comment">// by creating a method with the corresponding name. The method will</span>
  <span class="hljs-comment">// receive the plain old Javascript event object.</span>
  <span class="hljs-comment">//</span>
  mouseover (e) {
    <span class="hljs-comment">// ...</span>
  }

  change (e) {
    <span class="hljs-comment">// ...</span>
  }

  click (e) {
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// You may want to check which element in the component was actually</span>
    <span class="hljs-comment">// clicked. You can also check the `e.path` attribute to see what was</span>
    <span class="hljs-comment">// clicked (helpful when handling clicks on top of SVGs).</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">if</span> (!e.target.matches(<span class="hljs-string">'.parent'</span>)) <span class="hljs-keyword">return</span>

    <span class="hljs-comment">// ...</span>
  }

  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div&gt;&lt;/div&gt;`</span>
  }
}</code></pre>
<p>The convention of most frameworks is to attach individual event listeners,
such as <code>onClick={myHandler()}</code> or <code>click=myHandler</code>. In the case where
you have a table with 2000 rows, this would create 2000 individual listeners.</p>
<p>Tonic prefers the <a href="https://davidwalsh.name/event-delegate">event delegation</a> pattern. With event delegation, we
attach a <strong>single event listener</strong> and watch for interactions on the child
elements of a component. With this approach, fewer listeners are created and we
do not need to rebind them when the DOM is re-created.</p>
<p>Each event handler method will receive the plain old Javascript <code>event</code> object.
This object contains a <code>target</code> property, the exact element that was clicked.
The <code>path</code> property is an array of elements containing the exact hierarchy.</p>
<p>Some helpful native DOM APIs for testing properties of an element:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/matches"><code>Element.matches(String)</code></a> tests if an element matches a selector</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/closest"><code>Element.closest(String)</code></a> finds the closest ancestor from the element
that matches the given selector</li>
</ul>
<p>Tonic also provides a helper function which checks if the element matches the
selector, and if not, tries to find the closest match.</p>
<pre><code class="language-js">Tonic.matches(el, <span class="hljs-string">'selector'</span>)</code></pre>
<p>Here, when a particular element inside a child component is clicked, we
intercept the click event and pass along some data to the parent component.</p>
<h3>Example</h3>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  click (e) {
    e.detail.bar = <span class="hljs-literal">true</span>
  }
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div class="foo"&gt;Click Me&lt;/div&gt;`</span>
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  click (e) {
    <span class="hljs-keyword">if</span> (e.target.matches(<span class="hljs-string">'.foo'</span>)) {
      <span class="hljs-built_in">console</span>.log(e.detail.bar)
    }
  }
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;child&gt;&lt;/child&gt;`</span>
  }
}</code></pre>
<p>The event object has a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation"><code>Event.stopPropagation()</code></a> method that is useful for
preventing an event from bubbling up to parent components. You may also be
interested in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault"><code>Event.preventDefault()</code></a> method.</p>

    </section>
  

    <section id="6.-state">
      <h1 id="6-state">6. State</h1>
<p>Props are received by the parent and should never be changed by the component
that receives them. A component can however change its <code>state</code>. Each instance of
a component has state object, <code>this.state</code>. This is just a plain-old javascript
object. <code>this.setState()</code> can receive a value or a function.</p>
<pre><code class="language-js"><span class="hljs-comment">// Update a component's state</span>
<span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({
  ...state,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>
}))

<span class="hljs-comment">// Reset a component's state</span>
<span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> })</code></pre>
<hr>
<p><code>.setState()</code> will not cause a component to re-render. The reasoning behind this
is that the <code>state</code> can be updated independently, as needed &mdash; rendering
happens only when changes to the representation of the component are required.</p>

    </section>
  

    <section id="7.-composition">
      <h1 id="7-composition">7. Composition</h1>
<p>You may want to move the children of a component inside some additional layout
when the <code>render()</code> function is executed. The <code>this.children</code> property is helpful
for this. This is not a &quot;special&quot; member of the <code>props</code> object like React
(which is unintuitive), it&#39;s a member of the class instance.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
      &lt;div class="parent"&gt;
        &lt;another-component&gt;
          <span class="hljs-subst">${<span class="hljs-keyword">this</span>.children}</span>
        &lt;/another-component&gt;
      &lt;/div&gt;
    `</span>
  }
}

Tonic.add(Parent)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
      &lt;div class="child"&gt;
        <span class="hljs-subst">${<span class="hljs-keyword">this</span>.props.value}</span>
      &lt;/div&gt;
    `</span>
  }
}

Tonic.add(Child)</code></pre>
<h3>Input HTML</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"hello world"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre>
<h3>Output HTML</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">another-component</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">another-component</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre>

    </section>
  

    <section id="8.-performance">
      <h1 id="8-performance">8. Performance</h1>
<p>If you have lots of structure, but only a few changes, you could pre-render your
layout to create a reusable node and pass it to the render method. This
structure could also come from a <code>&lt;template&gt;</code> tag which my also improve
performance.</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherThing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tonic</span> </span>{
  <span class="hljs-keyword">constructor</span> (node) {
    <span class="hljs-keyword">super</span>(node)

    <span class="hljs-keyword">const</span> template = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'template'</span>)
    template.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'span'</span>))  

    <span class="hljs-keyword">this</span>.template = template.content
  }

  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Render will automatically deep-clone this node for you.</span>
  <span class="hljs-comment">//</span>
  render () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.template
  }
}</code></pre>
    </section>
  

    <section id="9.-csp">
      <h1 id="9-csp">9. CSP</h1>
<p><code>CSP</code> stands for <code>Content Security Policy</code>. It&#39;s important to add one of these
to your app or website if you do anything beyond pure html. <a href="https://developers.google.com/web/fundamentals/security/csp/">This</a> is a good
introduction to <code>CSP</code>s if you&#39;re not already familiar with how they work.</p>
<p>This is an example policy, it&#39;s quite liberal, in a real app you would want these
rules to be more specific.</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span>
  <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Security-Policy"</span>
  <span class="hljs-attr">content</span>=<span class="hljs-string">"
    default-src 'self';
    font-src 'self' https:;
    img-src 'self' https: data:;
    style-src 'self' 'nonce-123' https:;
    script-src 'self' 'nonce-123';
    connect-src 'self' https:;"</span>&gt;</span></code></pre>
<p>In order to allow <code>Tonic</code> to execute properly when using a CSP, you might need
to set the <code>Tonic.nonce</code> property. For example, given the above policy you would
add the following to your javascript...</p>
<pre><code class="language-js">Tonic.nonce = <span class="hljs-string">'123'</span></code></pre>
<p>Note that <code>123</code> is a placeholder, this should be an actual <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a>.</p>

    </section>
  

    <section id="api">
      <h1 id="apis">APIs</h1>
<h2>STATIC METHODS</h2>
<table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>add(Class, Object)</code></td>
<td align="left">Register a class as a new custom-tag and provide optional options for it.</td>
</tr>
<tr>
<td align="left"><code>escape(String)</code></td>
<td align="left">Escapes HTML characters from a string (based on <a href="https://github.com/mathiasbynens/he">he</a>).</td>
</tr>
<tr>
<td align="left"><code>sanitize(Object)</code></td>
<td align="left">Escapes all the strings found in an object literal.</td>
</tr>
<tr>
<td align="left"><code>match(Node, Selector)</code></td>
<td align="left">Match the given node against a selector or any matching parent of the given node. This is useful when trying to locate a node from the actual node that was interacted with.</td>
</tr>
</tbody></table>
<h2>INSTANCE METHODS</h2>
<table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>reRender(Object &#124; Function)</code></td>
<td align="left">Set the properties of a component instance. Can also take a function which will receive the current props as an argument.</td>
</tr>
<tr>
<td align="left"><code>getProps()</code></td>
<td align="left">Get the properties of a component instance.</td>
</tr>
<tr>
<td align="left"><code>setState(Object &#124; Function)</code></td>
<td align="left">Set the state of a component instance. Can also take a function which will receive the current props as an argument.</td>
</tr>
<tr>
<td align="left"><code>stylesheet()</code></td>
<td align="left">Returns a string of css to be lazily added to a <code>style</code> tag in the head.</td>
</tr>
<tr>
<td align="left"><code>styles()</code></td>
<td align="left">Returns an object that represents inline-styles. Styles are applied by adding a keys from the object to the <code>styles</code> attribute of an html tag in the render function, for example <code>styles=&quot;key1 key2&quot;</code>. Each object&#39;s key-value pair are added to the element&#39;s style object.</td>
</tr>
<tr>
<td align="left"><code>render()</code></td>
<td align="left">Returns HTML to be parsed or a dom node that will overwrite. There is usually no need to call this directly, prefer <code>componentInstance.reRender({ ... })</code>.</td>
</tr>
<tr>
<td align="left">html`...`</td>
<td align="left">Tidy up an HTML string (use as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">tagged template</a>).</td>
</tr>
</tbody></table>
<h2>&quot;LIFECYCLE&quot; INSTANCE METHODS</h2>
<table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>constructor(props)</code></td>
<td align="left">An instance of the element is created or upgraded. Useful for initializing state, setting up event listeners, or creating shadow dom. See the spec for restrictions on what you can do in the constructor. A constructor will receive an argument of <code>props</code> and must call <code>super(props)</code>.</td>
</tr>
<tr>
<td align="left"><code>willConnect()</code></td>
<td align="left">Called prior to the element being inserted into the DOM. Useful for updating configuration, state and preparing for the render.</td>
</tr>
<tr>
<td align="left"><code>connected()</code></td>
<td align="left">Called every time the element is inserted into the DOM. Useful for running setup code, such as fetching resources or rendering. Generally, you should try to delay work until this time.</td>
</tr>
<tr>
<td align="left"><code>disconnected()</code></td>
<td align="left">Called every time the element is removed from the DOM. Useful for running clean up code.</td>
</tr>
<tr>
<td align="left"><code>updated(oldProps)</code></td>
<td align="left">Called after reRender() is called. This method is not called on the initial render.</td>
</tr>
</tbody></table>

    </section>
  

          <footer>
            <div>
              <span>Made by</span>
              <svg>
                <use xlink:href="./logo-sprite.svg#cl_logo">
              </svg>
            </div>
            <div>
              <span>Supported by</span>
              <svg>
                <use xlink:href="./logo-sprite.svg#mp_logo">
              </svg>
            </div>
          </footer>
        </main>
        <script nonce="U29tZSBzdXBlciBzZWNyZXQ=" crossorigin="anonymous" src="bundle.js"></script>
      </body>
    </html>
  